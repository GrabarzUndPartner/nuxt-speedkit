import{_ as o,D as l,o as p,c as i,k as s,a as e,t as c,I as r,w as d,R as a}from"./chunks/framework._u06EGUx.js";const x=JSON.parse('{"title":"Usage","description":"","frontmatter":{"title":"Usage"},"headers":[],"relativePath":"v2/guide/usage.md","filePath":"v2/guide/usage.md"}'),h={name:"v2/guide/usage.md"},m={id:"frontmatter-title",tabindex:"-1"},y=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{$frontmatter.title}}"'},"​",-1),E=a(`<p>The following tools are provided to optimize your webpage:</p><h2 id="critical-prop-for-critical-components" tabindex="-1">Critical prop for critical components <a class="header-anchor" href="#critical-prop-for-critical-components" aria-label="Permalink to &quot;Critical prop for critical components&quot;">​</a></h2><p>A critical component is visible in the viewport when the web page is initially loaded. This can be communicated to the automated background process via a critical prop. The flag is passed on to all child components. This means that only the main component (organism) must be provided with it. With the help of this flag, the corresponding static resources (images &amp; fonts) are also declared as preload tags in the page head. All other components and their associated resources, that do not have a positive critical prop, are lazy loaded on demand.</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#FDAEB7;font-style:italic;">component</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">:critical</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;true&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#B31D28;font-style:italic;">component</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">:critical</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;true&quot;</span><span style="color:#24292E;"> /&gt;</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>In the current version, the critical flag must be set manually on the components. Automation would be conceivable in the future. However, according to current knowledge, this would have a massive impact on deployment times when using Puppeteer or similar tools. We are still collecting ideas here. If you know of a more efficient way, please send us a feature request.</p></div><h2 id="font-declaration" tabindex="-1">Font declaration <a class="header-anchor" href="#font-declaration" aria-label="Permalink to &quot;Font declaration&quot;">​</a></h2><p>The integration of fonts is component-based directly in the Vue template. All fonts, which have been declared in <code>nuxt.config</code>, can be assigned directly to the corresponding HTML element or component. In addition, subselectors and media queries can be defined, which enable viewport-based declarations or rich-text declarations. The cool thing about this is that it saves the additional declaration in the CSS. You no longer have to keep the template and the CSS with its corresponding selectors for fonts in sync. Yeah! This is extremely helpful, especially when it comes to theming.</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#FDAEB7;font-style:italic;">element</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-font</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;$fonts.getFont(…)&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#B31D28;font-style:italic;">element</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-font</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;$fonts.getFont(…)&quot;</span><span style="color:#24292E;"> /&gt;</span></span></code></pre></div><p><a href="/v2/directives/v-font.html">Learn more</a> about directive <code>v-font</code>.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Fonts are no longer explicitly defined via CSS, otherwise the loading behavior of the fonts cannot be controlled and an optimized loading behavior of the page can no longer be guaranteed.</p></div><h2 id="import-components" tabindex="-1">Import components <a class="header-anchor" href="#import-components" aria-label="Permalink to &quot;Import components&quot;">​</a></h2><p>Until now, components were imported either statically (<code>import component from &#39;@/component&#39;;</code>) or dynamically (<code>import(&#39;@/component&#39;)</code>). However, with these two variants, hydration cannot be controlled. As a result, all components are also initialized on initial load. <code>nuxt-speedkit</code> offers a corresponding loader for this feature request. Each async component import should be enclosed with this loader in a page or layout.</p><ul><li>&#39;Ensures that components are initialized only when needed in the visible viewport.&#39;</li><li>&#39;Optimizes initialization of critical components on initial page load (critical components are initially in the visible viewport).&#39;</li></ul><p>In the background, the module by <a href="https://github.com/maoberlehner/vue-lazy-hydration" target="_blank" rel="noreferrer">Markus Oberlehner</a> is used in a standardised way.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> speedkitHydrate </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;#speedkit/hydrate&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  components: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Stage: </span><span style="color:#B392F0;">speedkitHydrate</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">import</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;@/components/organisms/Stage&#39;</span><span style="color:#E1E4E8;">)),</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> speedkitHydrate </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;#speedkit/hydrate&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  components: {</span></span>
<span class="line"><span style="color:#24292E;">    Stage: </span><span style="color:#6F42C1;">speedkitHydrate</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">import</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;@/components/organisms/Stage&#39;</span><span style="color:#24292E;">)),</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div>`,15),u=s("code",null,"rootMargin",-1),g=a(`<div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Although the <code>#speedkit/hydrate</code> function can be used in any component, we recommend its explicit use only in pages and layout. Its use within components can be useful only in explicit special cases. Here we recommend the general use of static imports.</p></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>With <code>NODE-ENV (development)</code>, the components are included directly. <br>This is relevant for the hot reload of the imported vue files.</p></div><h2 id="speedkit-components" tabindex="-1">Speedkit Components <a class="header-anchor" href="#speedkit-components" aria-label="Permalink to &quot;Speedkit Components&quot;">​</a></h2><p>In order to be able to load further static resources such as pictures, iFrames or Vimeo/Youtube videos in the iFrame in a performance-optimised way, we provide the following components. The speedkit components can be imported via the namespace <code>#speedkit/components</code>.</p><ul><li><a href="/v2/components/speedkit-layer.html">SpeedkitLayer</a></li><li><a href="/v2/components/speedkit-picture.html">SpeedkitPicture</a></li><li><a href="/v2/components/speedkit-image.html">SpeedkitImage</a></li><li><a href="/v2/components/speedkit-iframe.html">SpeedkitIframe</a></li><li><a href="/v2/components/speedkit-vimeo.html">SpeedkitVimeo</a></li><li><a href="/v2/components/speedkit-youtube.html">SpeedkitYoutube</a></li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">speedkit-picture</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> SpeedkitPicture </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;#speedkit/components/SpeedkitPicture&#39;</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  components: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    SpeedkitPicture</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">speedkit-picture</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> SpeedkitPicture </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;#speedkit/components/SpeedkitPicture&#39;</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  components: {</span></span>
<span class="line"><span style="color:#24292E;">    SpeedkitPicture</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The speedkit components will be expanded in the future. If you have explicit wishes, please send us a feature request or directly a pull request with the corresponding feature 😃</p></div><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h2><p>You can check out a sample integration of <code>nuxt-speedkit</code> at <a href="https://github.com/GrabarzUndPartner/nuxt-speedkit-example" target="_blank" rel="noreferrer">Nuxt Speedkit Example</a>.</p><iframe class="embed-sandbox" src="//codesandbox.io/embed/github/GrabarzUndPartner/nuxt-speedkit-example/tree/main/?hidenavigation=1&amp;theme=dark"></iframe>`,10);function f(n,b,v,k,_,w){const t=l("nuxt-link");return p(),i("div",null,[s("h1",m,[e(c(n.$frontmatter.title)+" ",1),y]),E,s("p",null,[e("Whether a component is in the viewport or not is determined in the background by the intersection observer. If the initialisation is to take place earlier, e.g. when scrolling, this can be adjusted accordingly via the "),u,e(" option in the "),r(t,{to:"/options#lazyoffset"},{default:d(()=>[e("nuxt.config")]),_:1}),e(".")]),g])}const S=o(h,[["render",f]]);export{x as __pageData,S as default};
